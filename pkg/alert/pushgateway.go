package alert

import (
	"bytes"
	"fmt"
	"log"
	"net/http"
	"text/template"

	"go.vxn.dev/dish/pkg/config"
)

const (
	// jobName is the name of the Prometheus job used for dish results
	jobName = "dish_results"
)

// messageTemplate is a template used for the Pushgateway message generated by the createMessage method.
var messageTemplate = `
#HELP failed sockets registered by dish
#TYPE dish_failed_count counter
dish_failed_count {{ .FailedCount }}

`

// messageData is a struct used to store Pushgateway message template variables.
type messageData struct {
	FailedCount int
}

type pushgatewaySender struct {
	httpClient    HTTPClient
	url           string
	instanceName  string
	verbose       bool
	notifySuccess bool
	tmpl          *template.Template
}

// NewPushgatewaySender validates the provided URL, prepares and parses a message template to be used for alerting and returns a new pushgatewaySender struct with the provided attributes.
func NewPushgatewaySender(httpClient HTTPClient, config *config.Config) (*pushgatewaySender, error) {
	// Parse and validate the provided URL
	parsedURL, err := parseAndValidateURL(config.PushgatewayURL, nil)
	if err != nil {
		return nil, err
	}

	// Prepare and parse the message template to be used when pushing results
	tmpl, err := template.New("pushgatewayMessage").Parse(messageTemplate)
	if err != nil {
		return nil, fmt.Errorf("error creating Pushgateway message template: %w", err)
	}

	return &pushgatewaySender{
		httpClient:    httpClient,
		url:           parsedURL.String(),
		instanceName:  config.InstanceName,
		verbose:       config.Verbose,
		notifySuccess: config.MachineNotifySuccess,
		tmpl:          tmpl,
	}, nil
}

// createMessage returns a string containing the message text in Pushgateway-specific format.
func (s *pushgatewaySender) createMessage(failedCount int) (string, error) {
	var buf bytes.Buffer
	err := s.tmpl.Execute(&buf, messageData{FailedCount: failedCount})
	if err != nil {
		return "", fmt.Errorf("error executing Pushgateway message template: %w", err)
	}

	return buf.String(), nil
}

// Send pushes the results to Pushgateway.
//
// The first argument is needed to implement the MachineNotifier interface, however, it is ignored in favor of a custom message implementation via the createMessage method.
func (s *pushgatewaySender) send(_ *Results, failedCount int) error {
	// If no checks failed and success should not be notified, there is nothing to send
	if failedCount == 0 && !s.notifySuccess {
		if s.verbose {
			log.Println("no sockets failed, nothing will be sent to Pushgateway")
		}
		return nil
	}

	msg, err := s.createMessage(failedCount)
	if err != nil {
		return err
	}

	bodyReader := bytes.NewReader([]byte(msg))

	formattedURL := s.url + "/metrics/job/" + jobName + "/instance/" + s.instanceName

	err = handleSubmit(s.httpClient, http.MethodPut, formattedURL, bodyReader, withContentType("application/byte"))
	if err != nil {
		return fmt.Errorf("error pushing results to Pushgateway: %w", err)
	}

	log.Println("results pushed to Pushgateway")

	return nil
}
